1. 核心功能模块
   针对你提到的三种角色，功能分配如下：

👨‍💻 用户端 (User App)
目标：便捷下单，安全透明。

服务展示： 按照保洁、搬家、维修、保姆等分类展示服务项目及价格。

预约系统： 选择服务地址、期望时间、特殊要求（如是否有宠物）。

人员筛选： 查看服务人员的简历、评分、证书（健康证、职业技能证）及历史评价。

订单管理： 下单、支付（预付/定金）、取消订单、追踪服务状态。

互动评价： 服务完成后进行打分和文字/图片评论。

👷 服务人员端 (Staff App)
目标：高效接单，流程标准化。

个人中心： 维护个人简历、技能标签、空闲时间表。

接单系统： 接收系统派单或在抢单池中自主接单。

服务轨迹： 签到打卡（GPS定位）、上传服务前/后对比照。

收益结算： 查看每单提成、提现申请、收益流水。

💻 管理员后台 (Admin Web)
目标：资源调度，运营风控。

用户/人员管理： 审核服务人员资质，管理黑名单。

订单调度： 监控订单状态，手动干预异常订单。

财务报表： 对账管理、平台佣金设置、优惠券分发。

内容管理 (CMS)： 修改首页轮播图、公告、服务类目及定价。

2. 核心业务流程
   家政服务的闭环流程是整个软件的灵魂：

需求发布： 用户选择服务内容并支付定金。

派单/抢单： * 派单制： 平台根据距离和评分自动指派。

抢单制： 发布到公池，人员竞争。

上门服务： 服务人员到达后在小程序打卡，记录开始时间。

服务验收： 服务人员提交成果图，用户在线确认完成。

结算分润： 用户支付尾款，平台按比例扣除佣金，余款入账人员钱包。

3. 技术架构建议
   前端： 微信小程序原生开发（体验最好）或 Uni-app（方便后期扩展到支付宝等平台）。

后端： Java (Spring Boot) 或 Python (Django/FastAPI)，重点在于处理并发和稳定性。

数据库： MySQL 存储基础数据，Redis 缓存高频订单和经纬度信息。

关键技术：

地理位置服务： 利用腾讯/高德地图 SDK 实现自动定位、距离计算和轨迹追踪。

消息推送： 集成订阅消息，确保服务人员能第一时间收到接单提醒。

技术栈（Uni-app + Spring Boot + MySQL + Redis）设计的深度开发方案。

1. 核心架构设计
   全类目平台需要处理极高的并发（尤其是在抢单环节）和复杂的订单状态。

1.1 数据库建模 (MySQL)
由于是“全类目”，不同服务的规格不同（比如保洁按小时计费，空调清洗按台计费）。

服务表 (Service_Category)： 存储类目树（父子级）。

规格属性表 (Service_Spec)： 关联类目，定义计费单位、起步价、单位价。

地理围栏表 (Geo_Fence)： 定义服务覆盖范围，防止接单人员跨区太远。

状态机表 (Order_Log)： 记录订单从“待支付-待接单-上门中-服务中-待评价”的每一个时间节点。

1.2 高频数据处理 (Redis)
经纬度存储： 使用 Redis 的 GEO 数据类型。通过 GEOADD 存储服务人员实时坐标，利用 GEORADIUS 快速搜索附近 5km 内的师傅。

分布式锁： 在“抢单”场景下，必须使用 Redis 分布式锁，防止一个订单被多个人同时抢到。

热点缓存： 首页的服务分类、促销活动、高频评价等。

2. 关键技术实现方案
   📍 地理位置与路径规划
   对于全类目平台，距离就是成本。

智能排班： 结合高德/腾讯地图的路径规划 API。不仅仅是直线距离，还要计算步行/骑行时间，确保师傅在两单之间不会因为堵车或路程太远而迟到。

轨迹追踪： 师傅点击“出发”后，Uni-app 开启后台定位（需用户授权），每隔 1-3 分钟上报一次坐标，系统自动生成轨迹，增加用户的安全感。

📩 消息推送与响应
订阅消息： 由于是小程序，无法像 App 那样常驻后台。你需要在用户支付后、师傅接单后、师傅到达后，分别触发微信订阅消息模板。

响应队列： 使用 RabbitMQ 或 Redis List 作为缓冲。当大量订单产生时，异步处理派单逻辑，避免阻塞主业务逻辑。

开发全类目家政平台，核心难点在于如何用一套逻辑兼容“标准服务”（如保洁）和“非标服务”（如维修、搬家）。

**订单状态机逻辑**及**整体设计概要**。

---

## 1. 核心设计概要 (Design Abstract)

### 1.1 系统架构图

系统采用前后端分离架构，通过 RESTful API 进行交互。

* **前端 (Uni-app):** 一套代码发布至微信小程序，负责地图交互、支付对接、实名认证、实时消息展示。
* **后端 (Spring Boot):** 负责复杂的业务逻辑、派单算法、权限控制 (Spring Security/JWT)。
* **数据层:** * **MySQL:** 存储静态资源、用户信息、订单主表、账单。
* **Redis:** 存储人员实时位置 (`GEO`)、高频抢单锁、Session/Token。



---

## 2. 通用订单状态机 (Order State Machine)

为了兼容所有类目，我们将订单状态拆分为“主状态”和“子动作”。

### 2.1 状态流转表

| 状态码 | 状态名称 | 触发动作 | 适用场景 |
| --- | --- | --- | --- |
| `10` | **待支付定金** | 用户下单，锁定资源 | 所有服务 |
| `20` | **待接单/派单** | 支付成功，进入抢单池/自动指派 | 所有服务 |
| `30` | **待服务** | 师傅已接单，准备出发 | 所有服务 |
| `31` | **上门中** | 师傅点击“出发”，开启路径追踪 | 所有服务 |
| `40` | **待报价/补差价** | 师傅到达现场，发现实际工作量超标 | 维修、深度清洁、搬家 |
| `50` | **服务中** | 师傅点击“开始工作”，上传服务前照片 | 所有服务 |
| `60` | **待结算** | 师傅完成工作，上传完工照片 | 所有服务 |
| `70` | **已完成** | 用户确认验收，支付尾款 | 所有服务 |
| `80` | **已取消/退款** | 用户或后台发起取消 | - |

---

## 3. 关键技术逻辑实现思路

### 3.1 基于 Redis GEO 的“附近师傅”搜索

全类目平台需要快速匹配最近的服务人员。

* **更新位置：** 师傅端 Uni-app 每隔 3 分钟上报坐标：
  `GEOADD staff_locations 113.123 23.456 staff_88`
* **搜索附近：** 用户下单时，查询方圆 5km 内的师傅：
  `GEORADIUS staff_locations 113.123 23.456 5 km WITHDIST`

### 3.2 抢单并发控制 (Redis Distributed Lock)

当一个高频保洁单发布时，可能有 10 个师傅同时点“抢单”。

```java
// Spring Boot 伪代码逻辑
public boolean grabOrder(Long orderId, Long staffId) {
    String lockKey = "lock:order:" + orderId;
    // 使用 Redis SETNX 尝试加锁，有效期 5 秒
    boolean locked = redisTemplate.opsForValue().setIfAbsent(lockKey, staffId, 5, TimeUnit.SECONDS);
    if (locked) {
        try {
            // 1. 检查订单状态是否仍为“待接单”
            // 2. 更新订单状态为“已接单”，记录 staffId
            // 3. 异步发送订阅消息通知用户
            return true;
        } finally {
            // 释放锁（实际操作建议用 Lua 脚本保证原子性）
            redisTemplate.delete(lockKey);
        }
    }
    return false; // 抢单失败
}

```

### 3.3 非标服务的“补差价”逻辑

维修类服务通常先收“上门费”，现场看情况再加价。

* **实现方式：** 订单表设计 `parent_id`。当需要加价时，师傅在 App 端发起“增项申请”，系统生成一个关联主订单的**子支付单**。
* **风控：** 用户支付子订单后，主订单状态才允许流转到“已完成”。

---

## 4. 数据库核心表结构 (MySQL)

为了支持全类目，建议采用 **“主表 + 详情表”** 模式：

1. **`oms_order` (订单主表):** 存储订单号、用户ID、服务人员ID、基础金额、当前状态、经纬度。
2. **`pms_service_category` (服务类目表):** 存储保洁、月嫂、维修等层级，以及该类目的图标、计费单位。
3. **`oms_order_item` (服务清单表):** 存储具体服务项，如“空调清洗-挂机 * 2”。
4. **`ums_staff_skill` (师傅技能表):** 记录师傅能接哪些类目的单子（用于精准派单）。

---

## 5. 运营建议：如何让“全类目”不乱？

* **评价分层：** 保洁的评价不应影响师傅接维修单的权重，技能评价要垂直化。
* **价格自动化：** 尽量通过后台配置，让用户下单时就能勾选大部分选项（如：几个卧室、几台空调），减少线下的沟通成本。
* **实名与保险：** 对接第三方实名 SDK（如腾讯云、阿里云），并在师傅点击“开始服务”时自动触发一份保额极低的“单次家政意外险”。



## 1. 用户端功能原型描述 (User UI/UX)

对于“全类目”平台，用户端的设计核心是：**“三步触达服务”**。

### 1.1 首页 (Home)

* **顶部：** 定位（自动获取当前位置）、全局搜索框。
* **金刚区 (Grid)：** 采用 2x4 或 2x5 布局展示核心类目（日常保洁、家电清洗、保姆月嫂、家电维修等）。
* **营销位：** 轮播图 (Banner) 展示新用户优惠券或季节性热门服务。
* **附近师傅：** 信息流展示附近评分高的师傅头像、距离和擅长领域（增加信任感）。

### 1.2 下单流程 (Ordering Flow)

1. **类目页：** 点击“日常保洁”，进入详情。
2. **规格选择：** 弹出底栏，选择规格（如：3小时、4小时）或录入数量（如：空调挂机 x2）。
3. **信息填写：** * **地址：** 自动关联默认地址。
* **时间：** 动态时间轴，通过后端接口返回该地区当前可用的预约时段。
* **备注：** 语音/文字输入特殊要求。


4. **收银台：** 预估金额、优惠券抵扣、最终金额。支持微信支付。

---

## 2. 数据库物理设计 (DDL)

以下是针对 Spring Boot + MySQL 设计的核心表结构（精简了通用字段如 `create_time`, `update_time`）。

### 2.1 余额与结算相关表结构及变更（新增）

> 说明：用户余额通过微信支付进行充值，用户下单时优先使用余额支付。每一单完成后，平台按后台配置的规则（固定金额或百分比）抽取佣金，剩余部分计入服务人员钱包。

1. **用户余额（已存在，保持不变）**

```sql
-- 2. 客户/用户扩展表（已存在）
CREATE TABLE `ums_member` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`user_id` bigint NOT NULL COMMENT '关联sys_user',
`balance` decimal(10,2) DEFAULT 0.00 COMMENT '账户余额(微信充值 + 平台发放)',
`member_level` tinyint DEFAULT 0 COMMENT '会员等级',
FOREIGN KEY (`user_id`) REFERENCES `sys_user`(`id`)
) ENGINE=InnoDB COMMENT='客户信息表';
```

2. **服务人员钱包余额（需要在原表上新增字段）**

```sql
-- 3. 服务人员(师傅)扩展表（原有字段保持不变，增加 balance）
CREATE TABLE `ums_staff` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`user_id` bigint NOT NULL,
`real_name` varchar(32) NOT NULL COMMENT '真实姓名',
`id_card` varchar(20) COMMENT '身份证号(加密)',
`health_cert_url` varchar(255) COMMENT '健康证图片地址',
`service_score` decimal(3,2) DEFAULT 5.0 COMMENT '综合评分',
`order_count` int DEFAULT 0 COMMENT '累计接单数',
`work_status` tinyint DEFAULT 0 COMMENT '工作状态: 0-休息, 1-听单中, 2-服务中',
`audit_status` tinyint DEFAULT 0 COMMENT '审核状态: 0-待审核, 1-已通过, 2-驳回',
`auto_accept` tinyint NOT NULL DEFAULT 0 COMMENT '是否自动接单: 0-否, 1-是',
`balance` decimal(10,2) NOT NULL DEFAULT 0.00 COMMENT '师傅账户余额（可提现）',
FOREIGN KEY (`user_id`) REFERENCES `sys_user`(`id`)
) ENGINE=InnoDB COMMENT='师傅信息表';
```

> 实际数据库变更语句：
>
> ```sql
> ALTER TABLE `ums_staff`
>   ADD COLUMN `balance` decimal(10,2) NOT NULL DEFAULT 0.00 COMMENT '师傅账户余额（可提现）',
>   ADD COLUMN `auto_accept` tinyint NOT NULL DEFAULT 0 COMMENT '是否自动接单: 0-否, 1-是';
> ```

3. **订单分润字段（在订单主表上新增字段，用于快照记录每单分成结果）**

```sql
-- 6. 订单主表（在原有字段基础上新增分润与结算相关字段）
CREATE TABLE `oms_order` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`order_sn` varchar(64) UNIQUE NOT NULL COMMENT '订单号',
`member_id` bigint NOT NULL COMMENT '下单用户ID',
`staff_id` bigint DEFAULT NULL COMMENT '承接师傅ID',
`service_id` bigint NOT NULL COMMENT '服务ID',
`total_amount` decimal(10,2) NOT NULL COMMENT '订单总额',
`pay_amount` decimal(10,2) NOT NULL COMMENT '实付金额(含增项)',
`status` int NOT NULL DEFAULT 10 COMMENT '状态: 10-待支付, 20-待接单, 30-待服务, 40-服务中, 50-待结算, 60-已完成, 70-已取消',
`appointment_time` datetime NOT NULL COMMENT '预约时间',
`address_info` json NOT NULL COMMENT '地址快照(姓名、电话、经纬度、详细地址)',
`ext_info` json COMMENT '下单填写的动态表单数据',
`platform_amount` decimal(10,2) NOT NULL DEFAULT 0.00 COMMENT '本单平台抽成金额',
`staff_amount` decimal(10,2) NOT NULL DEFAULT 0.00 COMMENT '本单师傅收入金额',
`settle_time` datetime DEFAULT NULL COMMENT '结算完成时间',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='订单主表';
```

> 实际数据库变更语句：
>
> ```sql
> ALTER TABLE `oms_order`
>   ADD COLUMN `platform_amount` decimal(10,2) NOT NULL DEFAULT 0.00 COMMENT '本单平台抽成金额',
>   ADD COLUMN `staff_amount`    decimal(10,2) NOT NULL DEFAULT 0.00 COMMENT '本单师傅收入金额',
>   ADD COLUMN `settle_time`     datetime      DEFAULT NULL COMMENT '结算完成时间';
> ```

4. **服务人员钱包流水表（新增，用于记录每次结算、提现等资金变动）**

```sql
CREATE TABLE `ums_staff_wallet_log` (
`id` bigint NOT NULL AUTO_INCREMENT PRIMARY KEY,
`staff_id` bigint NOT NULL COMMENT '师傅ID，对应 ums_staff.id',
`order_id` bigint DEFAULT NULL COMMENT '关联订单ID，可为空（如手工调账）',
`change_type` tinyint NOT NULL COMMENT '1-订单收入, 2-提现, 3-后台调账',
`change_amount` decimal(10,2) NOT NULL COMMENT '正数增加，负数减少',
`balance_after` decimal(10,2) NOT NULL COMMENT '变动后的余额快照',
`remark` varchar(255),
`create_time` datetime DEFAULT CURRENT_TIMESTAMP,
KEY `idx_staff_id` (`staff_id`)
) ENGINE=InnoDB COMMENT='师傅钱包流水';
```

5. **结算配置表（新增，用于后台动态配置平台抽成规则：固定金额或百分比）**

```sql
CREATE TABLE `sys_config` (
`id` bigint NOT NULL AUTO_INCREMENT PRIMARY KEY,
`config_key` varchar(64) NOT NULL UNIQUE COMMENT '配置键，如 settle.mode',
`config_value` varchar(255) NOT NULL COMMENT '配置值，支持简单值或JSON',
`remark` varchar(255),
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='系统配置表';
```

- 推荐使用以下键值约定：
  - `settle.mode`：`fixed` / `percent`，表示平台抽成模式（固定金额 / 百分比）。
  - `settle.fixed_amount`：例如 `10.00`，每单固定扣除 10 元。
  - `settle.percent`：例如 `0.20`，表示平台抽成 20%，剩余 80% 计入师傅钱包。
  - `dispatch.weight.score`：历史评分权重 \(w_s\)，例如 `0.5`。
  - `dispatch.weight.distance`：距离权重 \(w_d\)，例如 `0.3`。
  - `dispatch.weight.punctual`：准时率/履约分权重 \(w_p\)，例如 `0.2`。
  - `dispatch.radius_km`：自动派单搜索半径（公里），例如 `5`。
  - `dispatch.max_concurrent_orders`：单个师傅允许的最大“进行中订单数”，用于控制负载。
  - `dispatch.enable_auto`：是否启用自动派单（`true`/`false`），关闭后仍保留抢单逻辑。

> 结算时机：当订单状态从“待结算(50)”流转到“已完成(60)”（用户确认完成）时，根据当前配置计算：
>
> - `orderIncome = pay_amount + 已支付增项金额之和`
> - 若 `mode = fixed`：`platform_amount = fixed_amount`，`staff_amount = orderIncome - platform_amount`
> - 若 `mode = percent`：`platform_amount = orderIncome * percent`，`staff_amount = orderIncome - platform_amount`
> - 将 `staff_amount` 累加到 `ums_staff.balance`，同时写入一条 `ums_staff_wallet_log` 作为资金流水
> - 将本次计算结果快照到 `oms_order.platform_amount`、`oms_order.staff_amount`、`oms_order.settle_time` 中，避免后续修改抽成配置影响历史订单

---

---

## 3. 全类目扩展：动态表单设计思路

由于搬家、维修、月嫂需要的表单字段完全不同（搬家需要楼层，维修需要电器品牌），建议在 `pms_category` 表中增加一个 `form_config` 字段（JSON格式）。

* **实现逻辑：** * Uni-app 端请求分类详情时，后端下发该类目的 JSON 表单配置。
* 前端根据配置动态渲染 `Input`、`Picker` 或 `Upload` 组件。
* 提交时，将这些非标数据存储在 `oms_order` 的 `ext_info` (JSON字段) 中。



---

## 4. 关键算法：派单权重公式

如果你不希望只是简单的“抢单”，可以引入一个**可在后台配置权重的派单评分公式**。

### 4.1 权重公式定义

设：

* \(S\)：师傅的历史综合评分（来源 `ums_staff.service_score`，范围 0–5，经标准化到 0–1）。
* \(D\)：距离得分，基于师傅当前位置与订单预约地址之间的距离（km），通过 Redis GEO 计算：
  * 实际距离为 `distKm`，系统配置搜索半径为 `R = dispatch.radius_km`；
  * 归一化为 \(D = \max(0, 1 - distKm / R)\)，即越近得分越高，超过半径则为 0。
* \(P\)：准时率 / 履约分，基于最近若干单的到达打卡时间、取消率等，从订单与状态日志中聚合计算后标准化到 0–1。

对应权重：

* \(w_s\)：评分权重，来自配置 `dispatch.weight.score`；
* \(w_d\)：距离权重，来自配置 `dispatch.weight.distance`；
* \(w_p\)：准时率权重，来自配置 `dispatch.weight.punctual`。

综合得分公式：

\[
W = w_s \cdot S + w_d \cdot D + w_p \cdot P
\]

后台可以通过修改 `sys_config` 中的这几个 `dispatch.weight.*` 配置键，实时调整三项在总分中的占比，而无需改代码或重启服务。

### 4.2 候选师傅筛选与排序

1. 候选条件（数据库过滤）：
   * `ums_staff.audit_status = 1`（已审核通过）。
   * `ums_staff.work_status = 1`（听单中）。
   * `ums_staff.auto_accept = 1`（开启自动接单）。
   * 具备当前订单类目所需技能（存在于 `ums_staff_skill` 中的对应记录）。
2. 业务过滤：
   * 统计该师傅当前“进行中”订单数（状态在 30/40/50），如超过 `dispatch.max_concurrent_orders` 则剔除。
3. 权重计算与排序：
   * 对候选师傅计算 \(S,D,P\) 及综合得分 \(W\)，按降序排序。
   * 选取得分最高的一位作为自动派单目标师傅。

### 4.3 触发时机与兜底策略

* **支付成功回调触发：**
  * 当订单从“待支付(10)”进入“待接单(20)”状态（支付成功），立即调用自动派单服务。
  * 自动派单服务内部使用现有的 `grabOrder` 乐观锁更新订单的 `staff_id` 与状态（从 20 → 30），并写入一条 `oms_order_status_log`，备注“系统自动派单”。
* **定时任务兜底：**
  * 即使支付成功时没有匹配到合适师傅，订单仍会留在“待接单池”。
  * 可以增加一个后台定时任务（例如每 1 分钟执行），扫描所有 `status = 20` 且 `staff_id IS NULL` 的订单，依次调用自动派单服务尝试分配，避免长时间无人接单。

---

## 5. 开发路线图 (Roadmap)

1. **第一阶段 (MVP):** 实现保洁类标准化下单、支付、手动派单、师傅接单、核销。
2. **第二阶段 (增强):** 接入 Redis GEO 定位、师傅实时轨迹、微信订阅消息通知。
3. **第三阶段 (全类目):** 实现动态表单配置、补差价逻辑、分销邀请奖励。

---

### 下一步建议

有了表结构和原型，下一步可以进行**代码框架的搭建**。


为了确保全类目家政平台的逻辑严密性，Spring Boot 后端的接口设计需要遵循 **RESTful 规范**，并针对用户、师傅、管理员进行权限隔离。

以下是核心 Controller 的设计方案，包含关键字段说明和业务逻辑注脚。对于接口需要采用token的方式进行认证

---

## 1. 统一响应结构 (Base Result)

在定义接口前，先确定标准返回格式，方便 Uni-app 端统一处理逻辑。

```java
public class Result<T> {
    private int code;      // 200-成功, 500-错误, 401-未登录
    private String msg;    // 提示信息
    private T data;        // 业务数据
}

```

---

## 2. 用户端接口 (User App API)

**前缀：** `/api/v1/user`

| 接口路径 | 请求方式 | 功能描述 | 关键逻辑 |
| --- | --- | --- | --- |
| `/category/list` | `GET` | 获取全类目列表 | 返回树形结构，包含图标和动态表单配置。 |
| `/order/create` | `POST` | 用户提交订单 | 校验预约时间，将非标数据存入 `ext_info`。 |
| `/order/pay` | `POST` | 发起微信支付 | 调用微信支付 SDK，生成预支付单。 |
| `/order/list` | `GET` | 个人订单中心 | 支持按状态（待支付、服务中等）过滤。 |
| `/order/cancel` | `POST` | 取消订单 | 判定当前状态，若师傅已出发则涉及违约金计算。 |

---

## 3. 师傅端接口 (Staff App API)

**前缀：** `/api/v1/staff`

| 接口路径 | 请求方式 | 功能描述 | 关键逻辑 |
| --- | --- | --- | --- |
| `/location/update` | `POST` | 上报实时经纬度 | 写入 Redis GEO，有效期设为 5-10 分钟。 |
| `/order/pool` | `GET` | 抢单池/待办任务 | 根据师傅当前位置，从 Redis 筛选 5km 内的订单。 |
| `/order/grab/{id}` | `POST` | **抢单核心接口** | **重点：** 使用 Redis 分布式锁，防止多人同时抢到。 |
| `/order/action` | `PUT` | 改变服务状态 | 动作包括：出发、抵达、开始、完成。需上传图片。 |
| `/order/extra-fee` | `POST` | 发起现场加价 | 维修/搬家类生成补差价单，推送给用户确认。 |

---

## 4. 核心代码实现 (Spring Boot 伪代码)

### 4.1 抢单逻辑 Controller

这是整个平台并发量最高、逻辑最核心的部分。

```java
@RestController
@RequestMapping("/api/v1/staff/order")
public class StaffOrderController {

    @Autowired
    private OrderService orderService;

    /**
     * 师傅抢单接口
     */
    @PostMapping("/grab/{orderId}")
    public Result<String> grabOrder(@PathVariable Long orderId) {
        // 1. 获取当前登录师傅ID (从JWT或Session)
        Long staffId = SecurityUtils.getCurrentStaffId();
        
        // 2. 调用Service层的分布式锁抢单逻辑
        boolean success = orderService.tryGrabOrder(orderId, staffId);
        
        if (success) {
            // 3. 异步发送订阅消息给用户：[您的订单已被接单]
            pushService.notifyUser(orderId, "您的订单已被接单，师傅正在准备中");
            return Result.success("抢单成功");
        } else {
            return Result.error("抢单失败，订单已被抢走或已失效");
        }
    }
}

```

### 4.2 订单流转接口

处理服务过程中的状态变更，例如“点击开始服务”。

```java
@PutMapping("/action")
public Result<String> updateStatus(@RequestBody OrderActionDTO dto) {
    // 动作类型：DEPART(出发), ARRIVE(到达), START(开始), FINISH(完成)
    // 校验：必须上传当前经纬度和现场照片(针对START/FINISH)
    orderService.processAction(dto); 
    return Result.success("状态更新成功");
}

```

---

## 5. 管理员端接口 (Admin Web API)

**前缀：** `/api/v1/admin`

### 5.1 管理员角色说明

| 角色 | 说明 | 权限 |
|------|------|------|
| **超级管理员** | 系统最高权限，通常为初始化创建 | 创建/禁用普通管理员、所有业务操作、查看/调整普通管理员余额 |
| **普通管理员** | 由超级管理员创建 | 用户/人员管理、订单调度、内容管理等；拥有独立余额账户 |

### 5.2 超级管理员专属接口

* **`POST /admin/create`**: 创建普通管理员账号（用户名、密码、昵称、手机号、初始余额）。
* **`GET /admin/list`**: 普通管理员列表（分页）。
* **`PUT /admin/{id}/status`**: 启用/禁用普通管理员。
* **`PUT /admin/{id}/balance`**: 调整普通管理员余额（充值/扣减）。

### 5.3 通用管理员接口（超级/普通均可）

* **`GET /dashboard/stats`**: 获取今日订单量、GMV、活跃师傅数。
* **`POST /order/dispatch`**: 强制派单（当某急单无人抢时，管理员手动指派）。
* **`PUT /staff/audit`**: 师傅资质审核（健康证、实名信息）。
* **`POST /settle/pay-out`**: 财务结算（打款给师傅）。

### 5.4 普通管理员专属接口

* **`GET /admin/me/balance`**: 查询自己的余额。

---

## 6. 系统时序图 (核心流程)

为了让你看清这些接口是如何串联的，参考以下时序：

1. **用户**调用 `/order/create` -> 后端写入 MySQL -> 消息推送到抢单池。
2. **师傅**通过 `/location/update` 保持在线 -> 后端更新 Redis GEO。
3. **师傅**调用 `/order/grab` -> 后端利用 Redis 锁判定结果 -> 更新 MySQL 状态。
4. **师傅**调用 `/order/action` (出发/到达) -> 后端记录轨迹并通知用户。

---

# 数据库设计：

-- 1. 统一用户基础表 (所有角色登录的基础)
CREATE TABLE `sys_user` (
`id` bigint NOT NULL AUTO_INCREMENT PRIMARY KEY,
`username` varchar(64) UNIQUE NOT NULL COMMENT '登录账号',
`password` varchar(100) NOT NULL COMMENT '加密密码',
`nickname` varchar(64) COMMENT '昵称',
`phone` varchar(20) UNIQUE COMMENT '手机号',
`avatar` varchar(255) COMMENT '头像',
`user_type` tinyint NOT NULL COMMENT '角色类型: 1-用户, 2-服务人员, 3-管理员(含超级/普通)',
`openid` varchar(100) COMMENT '微信小程序OpenID',
`status` tinyint DEFAULT 1 COMMENT '状态: 1-启用, 0-禁用',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP,
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='系统统一用户表';

-- 2. 客户/用户扩展表
CREATE TABLE `ums_member` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`user_id` bigint NOT NULL COMMENT '关联sys_user',
`balance` decimal(10,2) DEFAULT 0.00 COMMENT '账户余额',
`member_level` tinyint DEFAULT 0 COMMENT '会员等级',
FOREIGN KEY (`user_id`) REFERENCES `sys_user`(`id`)
) ENGINE=InnoDB COMMENT='客户信息表';

-- 3. 服务人员(师傅)扩展表
CREATE TABLE `ums_staff` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`user_id` bigint NOT NULL,
`real_name` varchar(32) NOT NULL COMMENT '真实姓名',
`id_card` varchar(20) COMMENT '身份证号(加密)',
`health_cert_url` varchar(255) COMMENT '健康证图片地址',
`service_score` decimal(3,2) DEFAULT 5.0 COMMENT '综合评分',
`order_count` int DEFAULT 0 COMMENT '累计接单数',
`work_status` tinyint DEFAULT 0 COMMENT '工作状态: 0-休息, 1-听单中, 2-服务中',
`audit_status` tinyint DEFAULT 0 COMMENT '审核状态: 0-待审核, 1-已通过, 2-驳回',
FOREIGN KEY (`user_id`) REFERENCES `sys_user`(`id`)
) ENGINE=InnoDB COMMENT='师傅信息表';

-- 3.1 管理员扩展表（区分超级管理员与普通管理员）
CREATE TABLE `sys_admin` (
`id` bigint NOT NULL AUTO_INCREMENT PRIMARY KEY,
`user_id` bigint NOT NULL UNIQUE COMMENT '关联sys_user',
`admin_type` tinyint NOT NULL COMMENT '管理员类型: 0-普通管理员, 1-超级管理员',
`balance` decimal(10,2) DEFAULT 0.00 COMMENT '账户余额(普通管理员使用，超级管理员可为0)',
`created_by` bigint COMMENT '创建者user_id，超级管理员为NULL表示系统初始化',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP,
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
KEY `idx_admin_type` (`admin_type`),
KEY `idx_created_by` (`created_by`),
FOREIGN KEY (`user_id`) REFERENCES `sys_user`(`id`)
) ENGINE=InnoDB COMMENT='管理员扩展表';

-- 4. 服务类目表
CREATE TABLE `pms_category` (
`id` int PRIMARY KEY AUTO_INCREMENT,
`parent_id` int DEFAULT 0 COMMENT '父类ID',
`name` varchar(32) NOT NULL COMMENT '类目名称',
`icon` varchar(255) COMMENT '分类图标',
`form_config` json COMMENT '动态表单配置(JSON): 定义下单时需要填写的特殊字段',
`sort` int DEFAULT 0,
`is_show` tinyint DEFAULT 1
) ENGINE=InnoDB COMMENT='服务类目表';

-- 5. 服务规格表 (具体产品)
CREATE TABLE `pms_service` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`category_id` int NOT NULL,
`title` varchar(128) NOT NULL COMMENT '服务标题: 如日常保洁',
`base_price` decimal(10,2) NOT NULL COMMENT '起步价/单价',
`unit` varchar(10) COMMENT '单位: 小时/台/平米',
`deposit_type` tinyint DEFAULT 0 COMMENT '支付模式: 0-全额支付, 1-只付定金, 2-线下报价',
`description` text COMMENT '服务详情介绍',
FOREIGN KEY (`category_id`) REFERENCES `pms_category`(`id`)
) ENGINE=InnoDB COMMENT='服务产品表';

-- 6. 订单主表
CREATE TABLE `oms_order` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`order_sn` varchar(64) UNIQUE NOT NULL COMMENT '订单号',
`member_id` bigint NOT NULL COMMENT '下单用户ID',
`staff_id` bigint DEFAULT NULL COMMENT '承接师傅ID',
`service_id` bigint NOT NULL COMMENT '服务ID',
`total_amount` decimal(10,2) NOT NULL COMMENT '订单总额',
`pay_amount` decimal(10,2) NOT NULL COMMENT '实付金额',
`status` int NOT NULL DEFAULT 10 COMMENT '状态: 10-待支付, 20-待接单, 30-待服务, 40-服务中, 50-待结算, 60-已完成, 70-已取消',
`appointment_time` datetime NOT NULL COMMENT '预约时间',
`address_info` json NOT NULL COMMENT '地址快照(姓名、电话、经纬度、详细地址)',
`ext_info` json COMMENT '下单填写的动态表单数据',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='订单主表';

-- 7. 订单状态变更日志 (用于追踪服务轨迹)
CREATE TABLE `oms_order_status_log` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`order_id` bigint NOT NULL,
`pre_status` int,
`post_status` int,
`operator` varchar(64) COMMENT '操作人',
`remark` varchar(255),
`create_time` datetime DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='订单状态追踪表';

-- 8. 现场加价/增项单
CREATE TABLE `oms_order_extra` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`order_id` bigint NOT NULL,
`title` varchar(100) COMMENT '加价原因',
`amount` decimal(10,2) NOT NULL,
`pay_status` tinyint DEFAULT 0 COMMENT '0-未付, 1-已付',
`evidence_pics` json COMMENT '现场图片凭证'
) ENGINE=InnoDB COMMENT='订单增项表';

-- 9. 服务评价表
CREATE TABLE `oms_order_comment` (
`id` bigint PRIMARY KEY AUTO_INCREMENT,
`order_id` bigint NOT NULL,
`member_id` bigint NOT NULL,
`staff_id` bigint NOT NULL,
`star` tinyint(1) COMMENT '星级1-5',
`content` varchar(500),
`pics` json COMMENT '评价图片',
`reply` varchar(500) COMMENT '师傅或后台回复'
) ENGINE=InnoDB COMMENT='服务评价表';

-- 10. 师傅技能关联表 (决定师傅能抢哪些类目的单)
CREATE TABLE `ums_staff_skill` (
`staff_id` bigint NOT NULL,
`category_id` int NOT NULL,
PRIMARY KEY (`staff_id`, `category_id`)
) ENGINE=InnoDB COMMENT='师傅技能表';

-- 11. 服务人员申请表（新建）
CREATE TABLE IF NOT EXISTS `ums_staff_apply` (
`id` bigint NOT NULL AUTO_INCREMENT PRIMARY KEY,
`user_id` bigint NOT NULL COMMENT '申请人ID(关联sys_user)',
`real_name` varchar(32) NOT NULL COMMENT '真实姓名',
`id_card` varchar(20) COMMENT '身份证号',
`phone` varchar(20) COMMENT '联系电话',
`health_cert_url` varchar(255) COMMENT '健康证图片地址',
`skill_cert_urls` json COMMENT '技能证书图片(JSON数组)',
`apply_reason` varchar(500) COMMENT '申请理由',
`status` tinyint NOT NULL DEFAULT 0 COMMENT '状态: 0-待审核, 1-已通过, 2-驳回',
`reject_reason` varchar(255) COMMENT '驳回原因',
`audit_time` datetime COMMENT '审核时间',
`audit_user_id` bigint COMMENT '审核人ID',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP,
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
KEY `idx_user_id` (`user_id`),
KEY `idx_status` (`status`),
KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='服务人员申请表';

JSON 字段的使用 (form_config, ext_info):

痛点: 保洁需要填“几房几厅”，搬家需要填“有无电梯”，维修需要填“品牌型号”。

方案: 在类目表定义 JSON 表单结构，下单时将填写的非标数据直接存入订单的 JSON 字段。避免了为每个类目建新表的麻烦。

地址快照:

订单表不直接关联地址 ID，而是存储地址信息的 JSON 快照。防止用户后续修改/删除默认地址后，历史订单的地址信息也跟着变了。

师傅审核流:

ums_staff 中的 audit_status 让管理员可以严格控制准入门槛。只有审核通过且 work_status 为“听单中”的师傅，Redis GEO 才会将其纳入派单范围。

管理员分层:

sys_admin 表区分超级管理员(admin_type=1)与普通管理员(admin_type=0)。超级管理员由系统初始化创建(created_by 为 NULL)，可创建普通管理员；普通管理员由超级管理员创建，拥有独立余额(balance)，可用于活动经费、补贴发放等业务场景。

状态追踪:

oms_order_status_log 记录了每一单从谁接的、几点出发、几点打卡的全部生命周期，是处理客诉的核心证据。

Redis 补充设计 (内存层)
实时位置: GEOADD staff:locations [lng] [lat] [staffId]

抢单锁: SETNX lock:order:[orderId] [staffId]

待接单池: 使用 Redis List 或 ZSet 存储当前待处理订单，方便师傅端准实时刷新。





